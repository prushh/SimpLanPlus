

state = {dec, load, deleted, error}
off = num
type = [int, bool]
point = num

id -> (type, off, state, point)

/gamma |- Declarations  : /gamma'
/gamma |- Statements  : /gamma', res(type)
/gamma |- exp : /gamma', res(type, point, state)


##############################################################################################################################################
##############################################################################################################################################


/gamma*[] |- Declarations : /gamma'	 	

/gamma'|- Statements : /gamma'', res(type)

/gamma'' = /gamma_0 * /gamma_1	

foreach var in /gamma_1 (var <= delete)

foreach s in Statements (if (s is RetNode) addToList sList) -> checkType(foreach sList istanceOf uguali)
----------------------------------------------------------------------------------------------------------[Block]
		/gamma |- {Declarations; Statements;} : /gamma_0, res.type



##############################################################################################################################################


id -> not_in(top(/gamma)) 	/gamma' = /gamma [id -> (type, off, dec, type.point)]

off = -(count(var) in /gamma + 1)
------------------------------------------------------------------------------[DecVar]
		/gamma |- type id ; : /gamma'


##############################################################################################################################################


id -> not_in(top(/gamma)) 	

/gamma |- exp : /gamma', res(type, point, state)	

(type.point != 0  &&  res.point != 0) || (type.point == 0  &&  res.point == 0)

type == res.type

/gamma'' = /gamma' [id -> (type, off, load, type.point)]

off = -(count(var) in /gamma' + 1)

------------------------------------------------------------------------------[DecVarAsg]
		/gamma |- type id = exp ; : /gamma''


##############################################################################################################################################


id -> not_in (top(/gamma))

/gamma*[id |-> ((T1 arg1, ... , Tn argn) |-> type ), arg1 -> T1, ... , argn -> Tn] |- Declarations; : /gamma'

/gamma' |- Statements; : /gamma'', res(type)

/gamma'' = /gamma_0 * /gamma_1

/gamma''' = /gamma_0 [id |-> ((T1 arg1, ... , Tn argn) -> type)]

type == res.type

/sigma_0 = [arg_1 -> /bottom, ... , arg_n -> /bottom]

/sigma_fun * /sigma_0 = [id -> /sigma_0 -> /sigma_1] |- {Declarations; Statements;} : /sigma_fun * /sigma_1[id -> /sigma_0 -> /sigma_1]

---------------------------------------------------------------------------------------------------------------------------[DecFun]
	/gamma |- type id (T1 arg1, ... , Tn argn) {Declarations; Statements;}: /gamma''', /sigma[id -> /sigma_0 -> /sigma_1]


##############################################################################################################################################


/gamma |- lhs : /gamma, res_1(type, point)	/gamma |- exp : /gamma', res_2(type,point,state)

(res_1.point != 0  &&  res_2.point != 0) || (res_1.point == 0  &&  res_2.point == 0)

res_1.type == res_2.type

/gamma'' = /gamma' [lhs.id -> (/gamma.lhs.id.type, /gamma.lhs.id.off, /gamma.lhs.id.state |> load, /gamma.lhs.id.point)]

-----------------------------------------------------------------------------------------------------------------------[Asg]
		/gamma |- lhs = exp ; : /gamma'', void


##############################################################################################################################################


/gamma |- lhs : /gamma, res(type, point)

res.point == 0

/gamma.lhs.id.point != 0

/gamma' = /gamma [lhs.id -> (/gamma.lhs.id.type, /gamma.lhs.id.off, /gamma.lhs.id.state |> delete, /gamma.lhs.id.point)]
--------------------------------------------------------------------------------------------------------------------------[Deletion]
				/gamma |- delete lhs ; : /gamma', void


##############################################################################################################################################


/gamma |- exp : /gamma', res(type, point, state)
--------------------------------------------------------------------------------------------------------------------------[Print]
				/gamma |- print exp ; : /gamma', void


##############################################################################################################################################


/gamma |- exp : /gamma', res(type, point, state)

res.point == 0
--------------------------------------------------------------------------------------------------------------------------[ReturnExp]
				/gamma |- return exp ; : /gamma', res.type


##############################################################################################################################################



--------------------------------------------------------------------------------------------------------------------------[ReturnNoExp]
				/gamma |- return ; : /gamma', void


##############################################################################################################################################


/gamma |- exp : /gamma', res_1(type, point, state)

res_1.type == bool

res_1.point == 0

/gamma' |- Statements : /gamma'', res_2(type)
--------------------------------------------------------------------------------------------------------------------------[It]
				/gamma |- if (exp) Statements : /gamma'', res_2.type


##############################################################################################################################################


/gamma |- exp : /gamma', res_1(type, point, state)

res_1.type == bool

res_1.point == 0

/gamma' |- S1: /gamma'', res_2(type)

/gamma' |- S2: /gamma''', res_3(type)

res_2.type == res_3.type

--------------------------------------------------------------------------------------------------------------------------[Ite]
				/gamma |- if (exp) S1 else S2: max(/gamma'', /gamma'''), res_2.type


##############################################################################################################################################


id in dom(/gamma)

/gamma.id.args.type # t1..tn

/gamma_i |- expi : /gamma_i+1, res_i(type, point, state)    // i in 0..n --- gamma_20 = gamma

(/gamma.id.args.type == res_i foreach arg.type)



(res_i.state <= delete foreach i)

->controllare che le exp siano utilizzabili in qualche modo (es. variabile non inizializzata)
->applicare il par nel senso bisogna fare la seq tra tipo exp1 e tutti gli altri, exp2 e tutti gli altri, expn e todos other
->find a way to ottenere lo state dell'exp se sono id quando finisce la chiamata di funzione

--------------------------------------------------------------------------------------------------------------------------[Call]
				/gamma |- id (exp1, ..., expn) ; : 

{

int f (^int a){

	a = a;
	return 0;			/sigma0 [a -> /bottom]  (/bottom /seq /rw)
					/sigma1 [a -> rw]
}

int ^b = new int;
delete b;
	
f(b+1);				(b.state /seq /wr) --> error
			
}

##############################################################################################################################################


id in dom(/gamma)

/gamma.id.args # t1..tn

/gamma |- expi : /gamma_i, res_i(type, point, state)

(/gamma.id.args.ti == res_i foreach arg)

->controllare che le exp siano utilizzabili in qualche modo (es. variabile non inizializzata)
->applicare il par nel senso bisogna fare la seq tra tipo exp1 e tutti gli altri, exp2 e tutti gli altri, expn e todos other
->stato all'espressione
->find a way to ottenere lo state dell'exp se sono id quando finisce la chiamata di funzione

/gamma.id.type != void

--------------------------------------------------------------------------------------------------------------------------[CallExp]
				/gamma |- id (exp1, ..., expn) : 


##############################################################################################################################################


NUMBER in Dom(Integer)

--------------------------------------------------------------------------------------------------------------------------[ValExp]
				/gamma |- NUMBER: /gamma', res(int, 0, load)


##############################################################################################################################################


BOOL in Dom(Boolean)

--------------------------------------------------------------------------------------------------------------------------[BoolExp]
				/gamma |- BOOL : /gamma', res(bool, 0, load)


##############################################################################################################################################


/gamma |- left : /gamma', res1(type, point, state)

op in [*, /, +, -]

/gamma' |- right : /gamma'', res2(type, point, state)

res1.type == res2.type == int

res1.point == res2.point == 0

state = max (res1.state, res2.state)
--------------------------------------------------------------------------------------------------------------------------[BinExp]
				/gamma |- left op right : /gamma'', res(int, 0, state)


##############################################################################################################################################


/gamma |- left : /gamma', res1(type, point, state)

op in [&&, ||]

/gamma' |- right : /gamma'', res2(type, point, state)

res1.type == res2.type == bool

res1.point == res2.point == 0

state = max (res1.state, res2.state)
--------------------------------------------------------------------------------------------------------------------------[BinBoolBoolExp]
				/gamma |- left op right : /gamma'', res(bool, 0, state)


##############################################################################################################################################


/gamma |- left : /gamma', res1(type, point, state)

op in [<, <=, >, >=]

/gamma' |- right : /gamma'', res2(type, point, state)

res1.type == res2.type == int

res1.point == res2.point == 0

state = max (res1.state, res2.state)
--------------------------------------------------------------------------------------------------------------------------[BinBoolIntExp]
				/gamma |- left op right : /gamma'', res(bool, 0, state)


##############################################################################################################################################


/gamma |- left : /gamma', res1(type, point, state)

op in [==, !=]

/gamma' |- right : /gamma'', res2(type, point, state)

res1.type == res2.type

res1.point == res2.point == 0

state = max (res1.state, res2.state)
--------------------------------------------------------------------------------------------------------------------------[BinBoolCosExp]
				/gamma |- left op right : /gamma'', res(bool, 0, state)


##############################################################################################################################################


/gamma |- exp : /gamma', res(type, point, state)

--------------------------------------------------------------------------------------------------------------------------[BaseExp]
				/gamma |- ( exp ) : /gamma', (res.type, res.point, res.state)


##############################################################################################################################################


/gamma |- exp : /gamma', res(type, point, state)

res.type == int

res.point == 0

--------------------------------------------------------------------------------------------------------------------------[NegExp]
				/gamma |- -exp : /gamma', res(int, 0, res.state)


##############################################################################################################################################


/gamma |- exp : /gamma', res(type, point, state)

res.type == bool

res.point == 0

--------------------------------------------------------------------------------------------------------------------------[NotExp]
				/gamma |- !exp : /gamma', res(bool, 0, res.state)


##############################################################################################################################################


split function for lhs cappellini tipo -> es: lhs.id, lhs.point]

lhs.id in(/gamma)

n = /gamma.lhs.id.point - lhs.id.point

--------------------------------------------------------------------------------------------------------------------------[DerNicoExp]
				/gamma |- lhs : /gamma', (/gamma.lhs.id.type, n, /gamma.lhs.id.state)


##############################################################################################################################################


split function for type cappellini tipo -> es: type.name, type.point]

type.name == bool \/ int

type.point == 0

--------------------------------------------------------------------------------------------------------------------------[NewExp]
				/gamma |- new type : /gamma, res(type.name, 1, load)

'''
int a = new int; #ERROR
^int a = new int; #OK
^^int a = new ^int; #OK

^^^int a = new int; ---- OK

// Da gestire nella generazione del bytecode
^^^ int a = new ^^int;
a^ = new ^int:
a^^ = new int;


^^int a = new ^int;

a^^
'''

##############################################################################################################################################